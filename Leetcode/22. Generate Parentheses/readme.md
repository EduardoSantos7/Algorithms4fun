# Algorithm Idea

The problem of generating all well-formed parentheses strings of length 2n can be decomposed into smaller subproblems of generating valid strings of smaller lengths.

By leveraging the solutions to these subproblems, we can construct the solutions to the original problem. To illustrate this point, consider the following approach. Let F(n) denote the set of all valid strings of length 2n. We can construct the elements of F(n) as follows:

Contatenating a valid string of length 0, generated by F(0), with a valid string of length 2n, generated by F(n). We can represent this concatenation as F(0)F(n) for simplicity.
Contatenating a valid string of length 2 from F(1) with a valid string of length 2n - 2 from F(n - 1), which is equivalent to F(1)F(n - 1).
F(2)F(n - 2).
F(3)F(n - 3).
...
F(n - 1)F(1).
F(n)F(0).

If n = 0, return [""].

Create an empty array answer = []. Iterate over the number of parentheses pairs with a variable left_count.

Iterate over each valid string left_string from generateParenthesis(left_count).

Iterate over each valid string right_string from generateParenthesis(n - left_count - 1).

Construct a valid string of length 2n: We enclose left_string by a pair of parentheses, which is denoted as ( + left_string + ), then contatenate it with right_string, and add the resulting string to answer.

Return answer when the nested iterations are complete.

# Complexity

- Time: O(4^n/sqr(n))

- Space:O(n)

# Results

Rust)

Runtime
3 ms
Beats
20%
Memory
2.2 MB
Beats
88%

Python)

Runtime
55 ms
Beats
16.33%
Memory
16.6 MB
Beats
21.90%