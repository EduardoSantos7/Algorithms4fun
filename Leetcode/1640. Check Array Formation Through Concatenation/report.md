# Algorithm Idea

The idea is to create an index before to know if we have elementss starting at that position, thatt way we can check that in O(1), then we create an array to store the "new order" at the end just compare if both arrays are the same.

# Complexity

- Time: O(N)

- Space:O(N)

# Results

Python)

- Runtime: 32 ms, faster than 98.38% of Python3 online submissions for Check Array Formation Through Concatenation.

- Memory Usage: 14.1 MB, less than 100.00% of Python3 online submissions for Check Array Formation Through Concatenation.

Rust)

- Runtime: 0 ms, faster than 100.00% of Rust online submissions for Check Array Formation Through Concatenation.

- Memory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Check Array Formation Through Concatenation.

Go)

- Runtime: 0 ms, faster than 100.00% of Go online submissions for Check Array Formation Through Concatenation.

- Memory Usage: 2.8 MB, less than 100.00% of Go online submissions for Check Array Formation Through Concatenation.

Kotlin)

- Runtime: 188 ms, faster than 46.15% of Kotlin online submissions for Check Array Formation Through Concatenation.

- Memory Usage: 38.7 MB, less than 5.13% of Kotlin online submissions for Check Array Formation Through Concatenation.