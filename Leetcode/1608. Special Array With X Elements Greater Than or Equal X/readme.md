# Algorithm Idea

Count the frequencies of numbers and then if you traverse that frequency backwards you can count how many numbers are bigger or equal to your current position if that match with the index return that index, in case you traverse all of the index without finding a match then return -1.

# Complexity

- Time: O(N)

- Space:O(N)

# Results

Python)

Runtime
41
ms
Beats
50.04%

Memory
16.60
MB
Beats
18.83%

Rust)

Runtime
1
ms
Beats
67.67%

Memory
2.07
MB
Beats
82.40%

Golang)

Runtime
1
ms
Beats
75.00%

Memory
2.41
MB
Beats
15.02%